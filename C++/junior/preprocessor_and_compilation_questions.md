# Juniour

## Preprocessor and Compilation

### 1. How does the process of compiling cpp files into a binary file work?

- Preprocessing: The preprocesser handles all the `#include` directives, `#define` macros, and conditional compilation instructions: `#ifndef`, `#ifdef`, `#endif`. It generates a `preprocessed` source file where all the macros and headers are expanded. This stage ensures that all the external dependencies (like header files are) included in the source code.

- Compilation: Converts the preprocessed source code into intermediate code, then into assembly code. The result of this step is `.s` (Unix Systems):
  
  - Syntax checks are performed
  - Semantics checks are do (e.g., type checking)
  - The intermediate object code is generated for each source file, which contains machine-level instructions but still lacks full program context (i.e., it cannot run yet)
  - Generate instantiation of templates.

- Assembly: The assembler converts the assembly code generated by the compiler into binary machine code. The machine code is specific to the platform on where it is compiling. The result of this step is an objet file (with `.o` or `.obj` extensions).

- Linking: The linker is responsible for combining one or more object files into a single executable. It resolves symbol references (such as functions or variables) that are used across multiple files. The linker also handles library linking. If your code depends on external libraries (like `libstdc++` for the standard library), the linker will include the necessary code from those libraries. The output of this step is an executable binary file (`a.out`, `program.exe`).

### 2. What is a preprocessor and how does a preprocessor work?

The preprocessor is a tool that process source code before the actual compilation begins. It handles various operations like including header files, defining macros, and setting up conditional compilation. The preprocessor commands are processed during the preprocessing step, which occurs before the compilation stage in the build process.

### 3. What preprocessor commands do you know?

- `#include`: Including header files
- `#define`: Defining macros: `#define PI 3.14159`
- `#ifndef`, `#ifdef`, `#endif`: Conditional compilation and guarding header files

### 4. What exactly does the linker link?

The linker is responsible for combining multiple object files (produces by the compiler) into a single executable. It also resolves any references to functions or variables between different object files.

- Object Files: The linker combines object files (`.o` or `.obj`) generated by the compiler into an executable. These object files contain machine code that is not yet fully connected. It resolves references between object files, so if one file refers to a function or variable defined in another, the linker will establish those connections.

- External Libraries: The linker also links external libraries (e.g., standard C++ libraries or thir-party libraries).

- Symbols and Addresses: The linker resolves symbol references (e.g., function calls, variable access) across the object files. It ensures that when a function is called, it is correctly linked to the function's address in memory.

- Static Linking: The linker copies all the necessary code from libraries directly into to executable at compile time.

- Dynamic Linking: The linker does not include the code from shared libraries directly but instead links to the library at runtime. This allows multiple programs to share the same library, saving memory.

- Relocation: If the object code has addresses that need to be adjusted (e.g., variables or function addresses), the linker performs relocation, which modifies the object code to use correct memory addresses.

### 5. What is compiler optimization?

Compiler optimization refers to techniques that compilers use to improve the performance and efficency of the generated machine code. The goal of optimization is to make the compiled program run faster, consume less memory, or use fewer resources while maintaining the same behaviour. These optimizations are applied during the compilation process and can be done at various levels (e.g., during code process and can be done at various levels (e.g., during code generation, instructions scheduling, and register allocation)).

- Loop Optimization:
  - Loop Unrolling: This involves expanding loops to reduce the overhead of loop control. By unrolling loops, the compiler minimizes the number of iterations, which can increase execution speed by reducing jumps and improving instruction-level parallelism.
  - Loop Invariant Code Motion: Moves computations that do not change inside loops out of the loop to minimize redundant calculations.

- Constant Folding and Propagation:
  - Constant Folding: The compiler evaluates constant expressions at compile-time rather than runtime. For example, 3 * 4 is computed at compile time instead of each time the program is run.
  - Constant Propagation: When a variable is assigned a constant value, the compiler replaces all instances of that variable with the constant.

- Dead Code Elimination:
  - The compiler removes code that does not affect the program's output. For example, if a variable is assigned a value but never used, the compiler will eliminate the assignment.

- Inline Expansion:
  - The compiler replaces a function call with the actual code of the function. This avoids the overhead of function calls (e.g., saving registers, jumping to the function, etc.) and can improve performance, especially for small functions.
  - However, excessive inlining can increase the size of the executable, so compilers must use this optimization judiciously.

- Register Allocation:
  - The compiler assigns variables to machine registers to improve access speed. Using registers instead of memory can significantly reduce the time needed for data retrieval.

- Level O (No Optimization):
  - This is default level where no optimizations are applied. This produces faster complation but results is less optimized code.
- Level 1 (Basic Optimization):
  - The compiler performs simple optimizations like constant folding, inlining, and dead code elimination.
- Level 2 (More Aggressive Optimization):
  - The compiler applies more advanced optimizations such as loop unrolling, stronger inlining, and instruction scheduling.
- Level 3 (Maximized Optimization):
  - The compiler applies the most aggressive optimizations available, including those that might significantly increase the size of the code. This level aims for the best performance at the cost of longer compile times.
- Profile-Guided Optimization (PGO):
  - The compiler collects runtime data and uses it to optimize the code based on how it is executed in real-world scenarios.

### 8. How to protect a header from being included again?

A traditional way to protect a header file from multiple inclusions is by using preprocessor directives:

```cpp
#ifndef HEADER_NAME_H  // Check if HEADER_NAME_H is not defined
#define HEADER_NAME_H  // Define HEADER_NAME_H

// Header file content here

#endif  // End of the conditional inclusion
```

Pros:

- Works in all C++ compilers
- Prevents multiple inclusions of the same file

Cons:

- Does not prevent cyclic dependencies (when two headers include each other)

How to Avoid Cyclic Dependencies

Cyclic dependencies happen when two or more headers include each other, causing an infinite inclusio loop.

- Forward Declarations
  - Instead of including a full header, declare the class in the header and include the full header in the `.cpp` file.
- Use `#include` Only When Necessary
  - Include a header only in the `.cpp` file if the header is not required in the `.h` file.

### 9. What are compilation flags?

Compilation flags are options passed to the compiler to control how a program is compiled and optimized. These flags can enable debugging, optimizations, warnings, and other behaiours.

Common Compilation Flags:

- Optimization Flags
- Debugging Flags
- Warning and Error Flags
- Standard Version Flags
- Linking and Library Flags
- Output File Flags

### 10. What does the include directive do?

The `#include` directive tells the preprocessor to include the contents of another file into the current file before compilation. This is typically used to include header files (`.h` or `.hpp`) that contain function declarations, class definitions, macros, or constants.

How it Works:

- The preprocessor replaces the #include directive with the full content of the specified file before the actual compilation starts.
- This allows different files to share common definitions without rewriting code.

### 12. How do macros work?

A macro is a predprocessor directive that defines a name for a constant value, function-like expression, or block of code. When a macro is used, the preprocessor replaces all occurrences of the macro with its defined value before compilation begins (at the preprocessing stage).

How Macros Work:

- Macros are processed at he preprocessing stage (before compilation).
- They replace occurrences of the macro name with actual value or expression.
- They do not perform type checking, unlike functions.
